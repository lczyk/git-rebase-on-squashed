#!/usr/bin/env bash
# spellchecker: ignore Marcin Konowalczyk unmatch

# Rebases the current branch on top of a squashed version of the base branch.
# Usage: git-rebase-on-squashed [--hard] <trunk-branch> <base-branch...>
# If --hard is provided, the files in the base branch will be kept track of,
# and any changes to those files in the current branch will be discarded.

set -euo pipefail

__VERSION__="0.2.0"
__AUTHOR__="Marcin Konowalczyk"

## LOGGING #####################################################################

RED='\033[0;31m'
BLUE='\033[0;34m'
YELLOW='\033[0;33m'
NC='\033[0m' # No Color

function _info() {
    [[ $QUIET -eq 1 ]] && return
    echo -e "${BLUE}INFO:${NC} $1"
}

function _error() {
    [[ $QUIET -eq 1 ]] && return
    echo -e "${RED}ERROR:${NC} $1" >&2
}

function _warn() {
    [[ $QUIET -eq 1 ]] && return
    echo -e "${YELLOW}WARNING:${NC} $1" >&2
}

function _fatal() {
    _error "$1"; exit 1;
}

function _not_implemented() {
    echo -e "${RED}NOT IMPLEMENTED:${NC} $1" >&2
    exit 2
}


# Adapted from post by Richard Hansen:
# https://stackoverflow.com/a/7287873/2531987
# CC-BY-SA 3.0

# Appends the command to the front of the existing trap command(s).
# If the trap is not yet set, sets it to the given command.
# Usage: defer 'echo hi' EXIT INT
function defer() {
    local defer_cmd="$1"
    shift || _fatal "${FUNCNAME[0]}: no command to add to trap"
    [[ "$#" -ge 1 ]] || _fatal "${FUNCNAME[0]}: no trap names given"
    extract_trap_cmd() { printf '%s\n' "$3"; }
    for defer_name in "$@"; do
        local existing_cmd=$(trap -p "${defer_name}")
        local new_cmd=""
        if [[ -z "$existing_cmd" ]]; then
            new_cmd="$defer_cmd"
        else
            new_cmd="$(
                printf '%s\n' "${defer_cmd}"
                eval "extract_trap_cmd $existing_cmd"
            )"
        fi
        trap -- "$new_cmd" "$defer_name" || _fatal "unable to modify trap ${defer_name}"
    done
}
# set the trace attribute for the above function. this is
# required to modify DEBUG or RETURN traps because functions don't
# inherit them unless the trace attribute is set
declare -f -t defer

################################################################################

_HELP="
usage: git-rebase-on-squashed [-h | --help] [v | --version]
       [--hard] [--trunk <trunk-branch>]
       <base-branch...>

Rebases the current branch on top of a squashed version of the base branch.

Options:
  --hard                Considers the files in the base branch as authoritative.
                        Any changes to those files in the current branch will be
                        discarded.
  --trunk <branch>      Specify the trunk branch (default: main).
  -b, --branch <branch> Specify the branch to rebase. If not provided, the
                        current branch will be used.
  -q, --quiet           Suppress informational messages.
  -h, --help            Show this help message and exit.
  -v, --version         Show version information and exit.
"
function usage () {
    # remove the first and last empty lines
    echo "$_HELP" | sed '/./,$!d' | sed -e :a -e '/^\n*$/{$d;N;};/\n$/ba'
}

QUIET=0
HARD_MODE=0
TRUNK_BRANCH="main"
BASE_BRANCHES=()
BASE_BRANCH=""
CURRENT_BRANCH=""
TARGET_BRANCH=""

function setup() {

    function _requires_arg() {
        if [[ -z "${2:-}" ]]; then
            _error "$1 requires an argument."
            usage
            exit 1
        fi
    }

    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            --hard) HARD_MODE=1; shift ;;
            -h|--help)
                usage
                exit 0 ;;
            -v|--version)
                echo "git-rebase-on-squashed version $__VERSION__"
                exit 0 ;;
            -q|--quiet) QUIET=1; shift ;;
            --trunk) 
                _requires_arg "--trunk" "$2"
                TRUNK_BRANCH="$2"; shift 2 ;;
            -b|--branch)
                _requires_arg "--branch" "$2"
                TARGET_BRANCH="$2"; shift 2 ;;
            --) shift; break ;;
            -*) _error "Unknown option: $1"; usage ;;
            *) break ;;
        esac
    done

    if [[ "$#" -lt 1 ]]; then
        usage
        exit 1
    fi

    # check if git is installed
    command -v git &> /dev/null || _fatal "Error: git is not installed."

    BASE_BRANCHES=("$@")

    # for now we support only one base branch
    [[ "${#BASE_BRANCHES[@]}" -eq 1 ]] || _fatal "Error: Only one base branch is supported for now."

    BASE_BRANCH="${BASE_BRANCHES[0]}"

    CURRENT_BRANCH="$(git rev-parse --abbrev-ref HEAD)"
}

function _remove_empty_elements() {
    local -n arr=$1
    local i=0
    while [[ $i -lt ${#arr[@]} ]]; do
        if [[ -z "${arr[$i]}" ]]; then
            unset 'arr[i]'
        else
            ((i++)) || true
        fi
    done
    # reindex the array
    arr=("${arr[@]}")
}

function main () {
    if [[ -n "$TARGET_BRANCH" ]]; then
        _info "Checking out target branch $TARGET_BRANCH"
        git checkout --quiet "$TARGET_BRANCH"
        defer "git checkout --quiet \"$CURRENT_BRANCH\"" EXIT
    else
        TARGET_BRANCH="$CURRENT_BRANCH"
    fi

    if [[ "$HARD_MODE" -eq 1 ]]; then
        _info "Hard mode enabled: changes to files in the head branch will be discarded."
    fi

    _info "Target branch: $TARGET_BRANCH"
    _info "Base branch: $BASE_BRANCH"

    # stash all changes
    if ! git diff --quiet || ! git diff --cached --quiet; then
        _info "Stashing changes..."
        git stash push -u -m "rebase-on-squashed: auto-stash"
        defer 'git stash pop || true' EXIT
    fi

    # make sure the base branch has a merge base with the trunk branch
    local base_merge_base
    base_merge_base=$(git merge-base "$TRUNK_BRANCH" "$BASE_BRANCH" || true)
    if [[ -z "$base_merge_base" ]]; then
        _fatal "The base branch '$BASE_BRANCH' has no common ancestor with the trunk branch '$TRUNK_BRANCH'."
    fi
    _info "Found common ancestor between $TRUNK_BRANCH and $BASE_BRANCH: $base_merge_base"

    local target_merge_base
    target_merge_base=$(git merge-base "$TRUNK_BRANCH" "$TARGET_BRANCH" || true)
    if [[ -z "$target_merge_base" ]]; then
        _fatal "The target branch '$TARGET_BRANCH' has no common ancestor with the trunk branch '$TRUNK_BRANCH'."
    fi
    _info "Found common ancestor between $TRUNK_BRANCH and $TARGET_BRANCH: $target_merge_base"

    if [[ "$target_merge_base" != "$base_merge_base" ]]; then
        _warn "The base branch '$BASE_BRANCH' and the target branch '$TARGET_BRANCH' have different common ancestors with the trunk branch '$TRUNK_BRANCH'."
        _warn "This may lead to unexpected results."
    fi
    # Create backup of the target branch
    local backup_target_branch="backup/rebase-on-squashed/${TARGET_BRANCH//\//-}"
    if git show-ref --verify --quiet "refs/heads/$backup_target_branch"; then
        _info "Deleting existing backup branch $backup_target_branch"
        git branch -D "$backup_target_branch"
    fi
    git branch --quiet "$backup_target_branch" "$TARGET_BRANCH"
    defer "[[ \$? -eq 0 ]] && git branch --quiet -D \"$backup_target_branch\" || true" EXIT

    # check in the history of the current branch if we already have a squash commit for the base branch
    local -r message_prefix="feat(ros)!"
    local -r message_sha="$(git rev-parse --short "$BASE_BRANCH")"

    # array of commits with messages starting with the expected prefix
    declare -a squash_commits
    readarray -t squash_commits <<<"$(git log --grep="^$message_prefix" --pretty=format:"%H" || true)"
    _remove_empty_elements squash_commits
    if [[ "${#squash_commits[@]}" -gt 1 ]]; then
        _not_implemented "Multiple squash commits found in the history of '$TARGET_BRANCH'. Handling this case is not implemented yet."
    fi

    if [[ "${#squash_commits[@]}" -eq 1 ]]; then
        _info "Found existing squash commit in the history of '$TARGET_BRANCH'."
        # There are some messages starting with the expected prefix.
        local squash_commit="${squash_commits[0]}"
        squash_commit_message=$(git log -1 --pretty=format:"%s" "$squash_commit" || true)
        squash_commit_message="${squash_commit_message#"$message_prefix: "}"
        local squash_commit_base=$(echo "$squash_commit_message" | sed -E "s/^Squashed branch '(.+)' at .*$/\1/" || true)
        if [[ "$squash_commit_base" != "$BASE_BRANCH" ]]; then
            _not_implemented "Found a squash commit ($squash_commit) for a different base branch ($squash_commit_base). Handling this case is not implemented yet."
        fi
        local squash_commit_sha=$(echo "$squash_commit_message" | sed -E "s/^Squashed branch '.+' at (.+)$/\1/" || true)
        if [[ "$squash_commit_sha" == "$message_sha" ]]; then
            _info "Branch '$TARGET_BRANCH' already has a squash commit for '$BASE_BRANCH' ($squash_commit). Nothing to do."
            exit 0
        fi
        
        # we are rebasing on a commit which is not the latest commit of the base branch
        # we need to remove it before proceeding
        git rebase --quiet --onto "$squash_commit^" "$squash_commit" "$TARGET_BRANCH"
    else
        _info "No existing squash commit found in the history of '$TARGET_BRANCH'."
    fi

    # create a new squashed version of the base branch
    local temp_branch="temp/rebase-on-squashed/${TARGET_BRANCH//\//-}-on-${BASE_BRANCH//\//-}"
    if git show-ref --verify --quiet "refs/heads/$temp_branch"; then
        _info "Deleting existing temporary branch $temp_branch"
        git branch --quiet -D "$temp_branch"
    fi

    _info "Creating temporary branch $temp_branch with squashed changes from $BASE_BRANCH"
    git checkout --quiet -b "$temp_branch" "$BASE_BRANCH"
    # shellcheck disable=SC2064
    defer "git checkout --quiet \"$TARGET_BRANCH\"; git branch --quiet -D \"$temp_branch\" || true" EXIT
    git reset --soft "$(git merge-base "$BASE_BRANCH" "$TARGET_BRANCH")"

    git commit \
        --quiet \
        --allow-empty \
        --author="$(git log -1 --pretty=format:'%an <%ae>' "$BASE_BRANCH")" \
        -m "$message_prefix: Squashed branch '$BASE_BRANCH' at $message_sha"

    _info "Rebasing $TARGET_BRANCH on top of $temp_branch"
    if [[ "$HARD_MODE" -eq 1 ]]; then
        # in hard mode, we want to keep track of the files in the base branch
        # and discard any changes to those files in the current branch
        # find files which are different between the base branch and its merge base with the trunk branch
        local base_files
        base_files=$(git diff --name-only "$base_merge_base" "$BASE_BRANCH")
        base_files=$(echo "$base_files" | tr '\n' ' ')
        if [[ -z "$base_files" ]]; then
            _warn "No files changed between $base_merge_base and $BASE_BRANCH. Nothing to discard."
            git checkout --quiet "$TARGET_BRANCH"
            git rebase "$temp_branch"
            return
        fi
        _info "Files changed in $BASE_BRANCH since $base_merge_base: $base_files"
        
        # modify the history of the current branch (up to the merge base with the trunk branch)
        # to discard changes to the base files. If the modified commit becomes empty, discard it.
        # NOTE: we do not want to remove files from history on every commit. We just want to, 
        #       for every commit, discard any changes to the base files.
        FILTER_BRANCH_SQUELCH_WARNING=1 git filter-branch \
            --force --prune-empty \
            --index-filter '
                changed_files=$(git diff-tree --no-commit-id --name-only -r "$GIT_COMMIT")
                for file in '"$base_files"'; do
                    if echo "$changed_files" | grep -q "^$file$"; then
                        git rm --cached --ignore-unmatch "$file"
                    fi
                done
            ' \
            -- "$target_merge_base..$TARGET_BRANCH"
        # remove the backup refs created by filter-branch
        git for-each-ref --format="%(refname)" refs/original/ \
            | grep "refs/original/refs/heads/$TARGET_BRANCH" \
            | xargs -n1 git update-ref -d
    fi

    git checkout --quiet "$TARGET_BRANCH"
    # rebase, but only the commits up to the merge base with the trunk branch
    local cmd="git rebase \
        --quiet \
        -X theirs \
        --onto \"$temp_branch\" \"$target_merge_base\" \"$TARGET_BRANCH\""
    _info "Running: $cmd"
    eval "$cmd"

    exit 0
}

setup "$@"
main